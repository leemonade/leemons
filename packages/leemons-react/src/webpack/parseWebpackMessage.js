/* eslint-disable no-console */
const chalk = require('chalk');
const ora = require('ora');
const url = require('url');
const address = require('address');

const spinner = ora();
global.spinner = spinner;

const friendlySyntaxErrorLabel = 'Syntax error:';

function isLikelyASyntaxError(message) {
  return message.indexOf(friendlySyntaxErrorLabel) !== -1;
}

// Cleans up webpack error messages.
function formatMessage(_messages) {
  let messages = _messages;
  let lines = [];

  if (typeof messages === 'string') {
    lines = messages.split('\n');
  } else if ('message' in messages) {
    lines = messages.message.split('\n');
  } else if (Array.isArray(messages)) {
    messages.forEach((message) => {
      if ('message' in message) {
        lines = message.message.split('\n');
      }
    });
  }

  // Strip webpack-added headers off errors/warnings
  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js
  lines = lines.filter((line) => !/Module [A-z ]+\(from/.test(line));

  // Transform parsing error into syntax error
  // TODO: move this to our ESLint formatter?
  lines = lines.map((line) => {
    const parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);
    if (!parsingError) {
      return line;
    }
    const [, errorLine, errorColumn, errorMessage] = parsingError;
    return `${friendlySyntaxErrorLabel} ${errorMessage} (${errorLine}:${errorColumn})`;
  });

  messages = lines.join('\n');
  // Smoosh syntax errors (commonly found in CSS)
  messages = messages.replace(
    /SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g,
    `${friendlySyntaxErrorLabel} $3 ($1:$2)\n`
  );
  // Clean up export errors
  messages = messages.replace(
    /^.*export '(.+?)' was not found in '(.+?)'.*$/gm,
    `Attempted import error: '$1' is not exported from '$2'.`
  );
  messages = messages.replace(
    /^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm,
    `Attempted import error: '$2' does not contain a default export (imported as '$1').`
  );
  messages = messages.replace(
    /^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm,
    `Attempted import error: '$1' is not exported from '$3' (imported as '$2').`
  );
  lines = messages.split('\n');

  // Remove leading newline
  if (lines.length > 2 && lines[1].trim() === '') {
    lines.splice(1, 1);
  }
  // Clean up file name
  lines[0] = lines[0].replace(/^(.*) \d+:\d+-\d+$/, '$1');

  // Cleans up verbose "module not found" messages for files and packages.
  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {
    lines = [
      lines[0],
      lines[1]
        .replace('Error: ', '')
        .replace('Module not found: Cannot find file:', 'Cannot find file:'),
    ];
  }

  // Add helpful message for users trying to use Sass for the first time
  if (lines[1] && lines[1].match(/Cannot find module.+sass/)) {
    lines[1] = 'To import Sass files, you first need to install sass.\n';
    lines[1] += 'Run `yarn add sass` inside your workspace.';
  }

  messages = lines.join('\n');
  // Internal stacks are generally useless so we strip them... with the
  // exception of stacks containing `webpack:` because they're normally
  // from user code generated by webpack. For more information see
  // https://github.com/facebook/create-react-app/pull/1050
  messages = messages.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, ''); // at ... ...:x:y
  messages = messages.replace(/^\s*at\s<anonymous>(\n|$)/gm, ''); // at <anonymous>
  lines = messages.split('\n');

  // Remove duplicated newlines
  lines = lines.filter(
    (line, index, arr) => index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim()
  );

  // Reassemble the message
  messages = lines.join('\n');
  return messages.trim();
}

function formatWebpackMessages(json) {
  const formattedErrors = json.errors.map((value) => formatMessage(value));
  const formattedWarnings = json.warnings.map((value) => formatMessage(value));
  const result = { errors: formattedErrors, warnings: formattedWarnings };
  if (result.errors.some(isLikelyASyntaxError)) {
    // If there are any syntax errors, show just them.
    result.errors = result.errors.filter(isLikelyASyntaxError);
  }
  return result;
}

function prepareUrls(protocol, host, port, pathname = '/') {
  const formatUrl = (hostname) =>
    url.format({
      protocol,
      hostname,
      port,
      pathname,
    });
  const prettyPrintUrl = (hostname) =>
    url.format({
      protocol,
      hostname,
      port: chalk.bold(port),
      pathname,
    });

  const isUnspecifiedHost = host === '0.0.0.0' || host === '::';
  let prettyHost;
  let lanUrlForConfig;
  let lanUrlForTerminal;
  if (isUnspecifiedHost) {
    prettyHost = 'localhost';
    try {
      // This can only return an IPv4 address
      lanUrlForConfig = address.ip();
      if (lanUrlForConfig) {
        // Check if the address is a private ip
        // https://en.wikipedia.org/wiki/Private_network#Private_IPv4_address_spaces
        if (/^10[.]|^172[.](1[6-9]|2[0-9]|3[0-1])[.]|^192[.]168[.]/.test(lanUrlForConfig)) {
          // Address is private, format it for later use
          lanUrlForTerminal = prettyPrintUrl(lanUrlForConfig);
        } else {
          // Address is not private, so we will discard it
          lanUrlForConfig = undefined;
        }
      }
    } catch (_e) {
      // ignored
    }
  } else {
    prettyHost = host;
  }
  const localUrlForTerminal = prettyPrintUrl(prettyHost);
  const localUrlForBrowser = formatUrl(prettyHost);
  return {
    lanUrlForConfig,
    lanUrlForTerminal,
    localUrlForTerminal,
    localUrlForBrowser,
  };
}

function printInstructions(urls) {
  console.log();
  console.log(chalk`{yellow Leemons} is ready to be enjoyed!`);
  if (urls.lanUrlForTerminal) {
    console.log(`  ${chalk.bold('Local:')}            ${urls.localUrlForTerminal}`);
    console.log(`  ${chalk.bold('On Your Network:')}  ${urls.lanUrlForTerminal}`);
  } else {
    console.log(`  ${urls.localUrlForTerminal}`);
  }

  console.log();
  console.log('Note that the development build is not optimized.');
  console.log(`To create a production build, use ${chalk.cyan(`yarn front:build`)}.`);
  console.log();
}

/**
 *
 * @param {import('webpack').Compiler} compiler
 */
async function parseWebpackMessage(compiler) {
  const { isTTY } = process.stdout;
  const urls = prepareUrls(
    'http',
    process.env.HOST || process.env.host || '0.0.0.0',
    process.env.PORT || process.env.port || '3000'
  );
  let isFirstCompilation = true;
  /*
    --- Compiling ---
  */

  compiler.hooks.run.tap('handleServerRun', () => {
    if (isTTY) {
      console.clear();
    }

    spinner.start('Compiling...');
  });

  compiler.hooks.invalid.tap('handleInvalid', () => {
    if (isTTY) {
      console.clear();
    }

    spinner.start('Compiling...');
  });

  compiler.hooks.done.tap('handleDone', (stats) => {
    if (isTTY) {
      console.clear();
    }

    const statsData = stats.toJson({
      all: false,
      errors: true,
      warnings: true,
      errorsCount: true,
      warningsCount: true,
    });

    if (stats.hasErrors()) {
      spinner.fail('Compiled with errors.');
    } else if (stats.hasWarnings()) {
      spinner.warn('Compiled with warnings.');
    } else {
      spinner.succeed('Compiled successfully.');
    }

    if (isFirstCompilation || statsData.errors?.length + statsData.warnings?.length === 0) {
      printInstructions(urls);
      isFirstCompilation = false;
    }

    if (stats.hasErrors() || stats.hasWarnings()) {
      const { errors, warnings } = formatWebpackMessages(statsData);

      if (errors?.length) {
        console.log(chalk.red('Failed to compile.\n'));
        console.log(errors[0]);
      }

      if (warnings?.length) {
        console.log(chalk.yellow('Compiled with warnings.\n'));
        console.log(warnings.join('\n\n'));
      }
    }
  });
}

module.exports = {
  parseWebpackMessage,
  formatWebpackMessages,
};
